<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/post/4a17b156.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/post/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Ⅰ、排序的概念及其运用"><a href="#Ⅰ、排序的概念及其运用" class="headerlink" title="Ⅰ、排序的概念及其运用"></a>Ⅰ、排序的概念及其运用</h2><h3 id="1-1-排序的概念"><a href="#1-1-排序的概念" class="headerlink" title="1.1 排序的概念"></a>1.1 排序的概念</h3><blockquote>
<p>​		<strong>排序：</strong> 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p>
<p>​		<strong>稳定性：</strong> 若经过排序，这些记录的序列的相对次序保持不变，即在原序列中，<strong>r[i] &#x3D; r[j]</strong> ，且 <strong>r[i]</strong> 在 <strong>r[j]</strong> 之前，而在排序后的序列中，<strong>r[i]</strong> 仍在 <strong>r[j]</strong> 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>​		<strong>内部排序：</strong> 数据元素全部放在内存中的排序。</p>
<p>​		<strong>外部排序：</strong> 数据元素太多不能同时放在内存中，根据排序过程的要求在内存外面的排序。（例如归并排序）</p>
</blockquote>
<h3 id="1-2常见的排序算法"><a href="#1-2常见的排序算法" class="headerlink" title="1.2常见的排序算法"></a>1.2常见的排序算法</h3><blockquote>
<ul>
<li>插入排序</li>
<li><strong>希尔排序</strong>💥</li>
<li>选择排序</li>
<li><strong>堆排序</strong>💥</li>
<li>冒泡排序</li>
<li><strong>快速排序</strong>💥</li>
<li><strong>归并排序</strong>💥</li>
<li>计数排序（非比较排序）</li>
<li>基数排序</li>
</ul>
</blockquote>
<h3 id="1-3排序算法的接口"><a href="#1-3排序算法的接口" class="headerlink" title="1.3排序算法的接口"></a>1.3排序算法的接口</h3><p><strong>排序</strong> <strong>OJ(可使用各种排序跑这个OJ)</strong> : <a href="https://leetcode.cn/problems/sort-an-array/submissions/">排序数组</a></p>
<figure class="highlight c"><figcaption><span>sort.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> root)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序递归实现</span></span><br><span class="line"><span class="comment">//三数取中函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetMidIndex</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="comment">// 快速排序hoare版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="comment">// 快速排序挖坑法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="comment">// 快速排序前后指针法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort3</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="comment">// 快速排序 非递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="comment">// 归并排序非递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-4测试算法接口"><a href="#1-4测试算法接口" class="headerlink" title="1.4测试算法接口"></a>1.4测试算法接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试排序的性能对比</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestOP</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="number">0</span>));</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line">	<span class="type">int</span>* a1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* a2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* a3 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* a4 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* a5 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* a6 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		a1[i] = rand();</span><br><span class="line">		a2[i] = a1[i];</span><br><span class="line">		a3[i] = a1[i];</span><br><span class="line">		a4[i] = a1[i];</span><br><span class="line">		a5[i] = a1[i];</span><br><span class="line">		a6[i] = a1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> begin1 = clock();</span><br><span class="line">	InsertSort(a1, N);</span><br><span class="line">	<span class="type">int</span> end1 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin2 = clock();</span><br><span class="line">	ShellSort(a2, N);</span><br><span class="line">	<span class="type">int</span> end2 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin3 = clock();</span><br><span class="line">	SelectSort(a3, N);</span><br><span class="line">	<span class="type">int</span> end3 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin4 = clock();</span><br><span class="line">	HeapSort(a4, N);</span><br><span class="line">	<span class="type">int</span> end4 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin5 = clock();</span><br><span class="line">	QuickSort(a5, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> end5 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin6 = clock();</span><br><span class="line">	MergeSort(a6, N);</span><br><span class="line">	<span class="type">int</span> end6 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;InsertSort:%d\n&quot;</span>, end1 - begin1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ShellSort:%d\n&quot;</span>, end2 - begin2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SelectSort:%d\n&quot;</span>, end3 - begin3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;HeapSort:%d\n&quot;</span>, end4 - begin4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;QuickSort:%d\n&quot;</span>, end5 - begin5);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MergeSort:%d\n&quot;</span>, end6 - begin6);</span><br><span class="line">	<span class="built_in">free</span>(a1);</span><br><span class="line">	<span class="built_in">free</span>(a2);</span><br><span class="line">	<span class="built_in">free</span>(a3);</span><br><span class="line">	<span class="built_in">free</span>(a4);</span><br><span class="line">	<span class="built_in">free</span>(a5);</span><br><span class="line">	<span class="built_in">free</span>(a6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="附：Swap接口（使用异或的方法实现）"><a href="#附：Swap接口（使用异或的方法实现）" class="headerlink" title="附：Swap接口（使用异或的方法实现）"></a>附：Swap接口（使用异或的方法实现）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*a == *b)<span class="comment">//这个条件要加，因为如果两个数相等，会变成0</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    *a ^= *b;</span><br><span class="line">    *b ^= *a;</span><br><span class="line">    *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点： <mark class="hl-label blue">无需开辟临时变量，且不会发生溢出。</mark> </p>
<hr>
<h2 id="Ⅱ、排序算法的实现"><a href="#Ⅱ、排序算法的实现" class="headerlink" title="Ⅱ、排序算法的实现"></a>Ⅱ、排序算法的实现</h2><h3 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h3><blockquote>
<p><strong>基本思想：</strong></p>
<p>​		直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。</p>
<p>​		实际中我们玩扑克牌时，就用了插入排序的思想。</p>
<img src="../images/blog_images/image-20220715222722321.png" alt="image-20220715222722321" style="zoom: 67%;" />

<p><strong>直接插入排序：</strong></p>
<p>​		当插入第 <strong>i (i &gt;&#x3D; 1)</strong> 个元素时，前面的 <strong>array[0], array[1],…,array[i - 1]</strong> 已经排好序，此时用 <strong>array[i]</strong> 的排序码与 <strong>array[i - 1],array[i - 2],…</strong> 的排序码顺序进行比较，找到插入位置即将 <strong>array[i]</strong> 插入，原来位置上的元素顺序后移。</p>
<img src="../images/blog_images/image-20220715223212669.png" alt="image-20220715223212669" style="zoom: 80%;" />

<p><strong>直接插入排序的特性总结：</strong></p>
<ol>
<li><p>元素集合<strong>越接近有序</strong>，直接插入排序算法的时间<strong>效率越高</strong></p>
</li>
<li><p>时间复杂度：<strong>O(N^2)</strong></p>
</li>
<li><p>空间复杂度：<strong>O(1)</strong> ，它是一种稳定的排序算法</p>
</li>
<li><p>稳定性：<strong>稳定</strong></p>
</li>
</ol>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> end = i;</span><br><span class="line">        <span class="type">int</span> tmp = arr[end + <span class="number">1</span>]; <span class="comment">// 每次对比的基准值</span></span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若发现可以插入tmp，则将arr当前位置向后移动</span></span><br><span class="line">            <span class="keyword">if</span>(arr[end] &gt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[end + <span class="number">1</span>] = arr[end];</span><br><span class="line">                --end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        arr[end + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2、希尔排序-缩小增量排序-🍪"><a href="#2、希尔排序-缩小增量排序-🍪" class="headerlink" title="2、希尔排序( 缩小增量排序 )🍪"></a>2、<strong>希尔排序( 缩小增量排序</strong> )🍪</h3><blockquote>
<p><strong>希尔排序的由来：</strong></p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li><strong>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</strong></li>
<li><strong>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</strong></li>
</ol>
<p>在以前排序算法不多的时候，科学家们想着如何优化时间复杂度…….</p>
<p>这时希尔想到 <strong>插入排序最坏的情况是O(N^2)</strong> 是在序列逆序的情况下，以目标排升序为例，最大的数字在最前面，那么要是将插入进行分组会不会交换的更快？答案是确实是快了！</p>
<p>因为将插入排序的思想进行分组插入后，如果分组越大，那么大的数字能更快的向后移动，而分组越小，大的数字就会越慢的向后移动。相反，分组越大，那么这个序列也越不接近有序，而分组越小，反而越接近有序。</p>
<p>所以希尔就根据这种特点，创造了缩小增量排序的基本思想！</p>
<p><strong>简单来说：</strong></p>
<p>希尔排序是按照不同步长对元素进行<a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a>，<strong>当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。</strong>所以，希尔排序的<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a>会比 <strong>O(n^2)</strong> 好一些。</p>
<p><strong>实质就是一种分组插入的思想！</strong></p>
<img src="../images/blog_images/image-20220715225637620.png" alt="image-20220715225637620" style="zoom: 67%;" />

<p><strong>希尔排序的特性总结：</strong></p>
<ol>
<li><p><strong>希尔排序是对直接插入排序的优化</strong>。</p>
</li>
<li><p><strong>当 gap &gt; 1 时都是预排序，目的是让数组更接近于有序</strong>。当 <strong>gap&#x3D;&#x3D;1</strong> 时，<strong>数组已经接近有序的了，这样就会很快</strong> ， <strong>可看作 O(n)</strong> 。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。</p>
</li>
<li><p>希尔排序的时间复杂度不好计算，需要进行推导，推导出来<strong>平均时间复杂度： O(N^1.3—N^2）</strong></p>
</li>
<li><p>稳定性：<strong>不稳定</strong></p>
</li>
</ol>
</blockquote>
<p><strong>总结：</strong></p>
<blockquote>
<p><strong>gap 越大，大的和小的数可以<u>更快</u>的挪到对应的方向去</strong></p>
<p><strong>gap 越大，<u>越不接近有序</u></strong></p>
</blockquote>
<blockquote>
<p><strong>gap 越小，大的和小的数可以<u>更慢</u>的挪到对应的方向去</strong></p>
<p><strong>gap 越小，<u>就越接近有序</u></strong></p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> gap = n;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gap = (gap / <span class="number">3</span>) + <span class="number">1</span>; <span class="comment">// 加一防止gap最后为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> end = i;</span><br><span class="line">            <span class="type">int</span> tmp = arr[end + gap];</span><br><span class="line">            <span class="keyword">while</span>(end &gt;= <span class="number">0</span>) <span class="comment">// 与插入排序思想一致</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[end] &gt; tmp)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[end + gap] = arr[end]; <span class="comment">// 注意要向后gap位移动</span></span><br><span class="line">                    end -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[end + gap] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h3><blockquote>
<p><strong>基本思想：（采用双向选择，同时找大找小，进行一定程度的优化）</strong></p>
<p>每一次从待排序的数据元素中选出最小和最大的两个元素，存放在序列的起始位置以及末尾，直到全部待排序的数据元素排完 。</p>
<p><strong>直接选择排序:</strong></p>
<ul>
<li>在元素集合 array[i] — array[n-1] 中选择关键码最大与最小的数据元素</li>
<li>若它不是这组元素中的最后一个或者第一个元素，则将它与这组元素中的最后一个或第一个元素交换</li>
<li>在剩余的 array[i] — array[n-2]（array[i+1]—array[n-1]）集合中，重复上述步骤，直到集合剩余一个元素</li>
</ul>
<p><strong>直接选择排序的特性总结：</strong></p>
<ol>
<li><p>直接选择排序思考非常好理解，但是<strong>效率不是很好。实际中很少使用</strong></p>
</li>
<li><p>时间复杂度：<strong>O(N^2)</strong></p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
<li><p>稳定性：<strong>不稳定</strong></p>
</li>
</ol>
</blockquote>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同时找最大和最小，从两边开始互换位置</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> max = left;</span><br><span class="line">        <span class="type">int</span> min = right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right + <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; min)</span><br><span class="line">                min = i</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)</span><br><span class="line">                max = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Swap(&amp;arr[left], &amp;arr[min]);</span><br><span class="line">         <span class="comment">// 如果max和left位置重叠，max被换走了，要修正一下max的位置</span></span><br><span class="line">        <span class="keyword">if</span> (left == max)</span><br><span class="line">            max = min;</span><br><span class="line">        Swap(&amp;arr[right], &amp;arr[max]);</span><br><span class="line"></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4、-堆排序🧨"><a href="#4、-堆排序🧨" class="headerlink" title="4、 堆排序🧨"></a>4、 堆排序🧨</h3><blockquote>
<p>堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。<strong>需要注意的是排升序要建大堆，排降序建小堆。</strong> （具体的参考二叉树中的堆的笔记）</p>
<img src="../images/blog_images/image-20220716082753546.png" alt="image-20220716082753546" style="zoom:80%;" />

<p><strong>堆排序的特性总结：</strong></p>
<ol>
<li><p>堆排序使用堆来选数，效率就高了很多。</p>
</li>
<li><p>时间复杂度：<strong>O(N*logN)</strong>   —&gt;向下调整的 <strong>logN</strong> 层乘以一共 <strong>N</strong> 个节点</p>
</li>
<li><p>空间复杂度：<strong>O(1)</strong></p>
</li>
<li><p>稳定性：<strong>不稳定</strong></p>
</li>
</ol>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向下调整算法（大堆）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n, <span class="type">int</span> root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> parent = root;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 默认为左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(child &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果右孩子存在，并且右孩子大于左孩子则变成右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            child += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[parent] &lt; arr[child])</span><br><span class="line">        &#123; </span><br><span class="line">            Swap(&amp;arr[parent], &amp;arr[child]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 这步很关键，没有break会造成死循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建大堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (n<span class="number">-1</span><span class="number">-1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        AdjustDown(arr, n, i);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次交换堆顶与堆的最后一个元素，然后重新向下调整</span></span><br><span class="line">        Swap(&amp;arr[<span class="number">0</span>], &amp;arr[end]);</span><br><span class="line">        AdjustDown(arr, end, <span class="number">0</span>);</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5、冒泡排序"><a href="#5、冒泡排序" class="headerlink" title="5、冒泡排序"></a>5、冒泡排序</h3><blockquote>
<img src="../images/blog_images/image-20220716133313750.png" alt="image-20220716133313750" style="zoom:67%;" />

<p><strong>冒泡排序的特性总结：</strong></p>
<ol>
<li><p>冒泡排序是一种非常容易理解的排序</p>
</li>
<li><p>时间复杂度：<strong>O(N^2)</strong> </p>
</li>
<li><p>空间复杂度：<strong>O(1)</strong></p>
</li>
<li><p>稳定性：<strong>稳定</strong></p>
</li>
</ol>
</blockquote>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="comment">// 若其中一次有序说明不需要再排序了，则直接break</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6、快速排序🎍"><a href="#6、快速排序🎍" class="headerlink" title="6、快速排序🎍"></a>6、快速排序🎍</h3><h4 id="递归实现版本："><a href="#递归实现版本：" class="headerlink" title="递归实现版本："></a><strong>递归实现版本：</strong></h4><blockquote>
<p>快速排序是Hoare于1962年提出的一种<strong>二叉树结构的交换排序方法</strong>，其基本思想为：任取待排序元素序列中的某元素作为<strong>基准值</strong>，按照该排序码将待排序集合分割成两子序列，<strong>左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值</strong>，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</p>
<p>将区间按照基准值划分为左右两半部分的常见方式有：（会一种即可）</p>
<ol>
<li><p><strong>hoare版本</strong></p>
</li>
<li><p><strong>挖坑法</strong></p>
</li>
<li><p><strong>前后指针版本</strong></p>
</li>
</ol>
<img src="../images/blog_images/image-20220716133917429.png" alt="image-20220716133917429" style="zoom: 80%;" />

<img src="../images/blog_images/image-20220716152548953.png" alt="image-20220716152548953" style="zoom:67%;" />

<p><strong>快速排序的特性总结：</strong></p>
<ol>
<li><p>快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫<strong>快速</strong>排序</p>
</li>
<li><p>时间复杂度：<strong>O(N*logN)</strong></p>
</li>
</ol>
<img src="../images/blog_images/image-20220716172704541.png" alt="image-20220716172704541" style="zoom:67%;" />

<ol start="3">
<li><p>空间复杂度：<strong>O(logN)</strong>   （递归树的深度）</p>
</li>
<li><p>稳定性：<strong>不稳定</strong></p>
</li>
</ol>
</blockquote>
<p>在写出个版本之前，我们先写出快速排序的主函数，<strong>让各版本的快排作为子函数，降低耦合性</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)  <span class="comment">//递归结束的条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> key = PartQuickSort(arr, left, right); <span class="comment">//将快排作为子函数排序</span></span><br><span class="line">    </span><br><span class="line">    QuickSort(arr, left, key <span class="number">-1</span>);    <span class="comment">//继续递归调用子区间</span></span><br><span class="line">    QuickSort(arr, key + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而在快排的主函数中，我们又可以有以下两种优化手段：</p>
<blockquote>
<ol>
<li><strong>三数取中法</strong> 取key</li>
<li>递归到<strong>小的子区间</strong>时，可以<strong>考虑使用插入排序</strong></li>
</ol>
</blockquote>
<h5 id="对于-三数取中-与-小区间优化-的方法："><a href="#对于-三数取中-与-小区间优化-的方法：" class="headerlink" title="对于 三数取中 与 小区间优化 的方法："></a><strong>对于 <u>三数取中</u> 与 <u>小区间优化</u> 的方法</strong>：</h5><blockquote>
<p><strong>优化的产生原因：</strong></p>
<p>在<strong>理想情况</strong>下，我们都<strong>希望每次更好都是二分</strong>，每行有 N 个数，共有 logN 行，所以<strong>时间复杂度为O(N*logN)</strong></p>
<img src="../images/blog_images/image-20220716153529025.png" alt="image-20220716153529025" style="zoom: 80%;" />

<p>但是对于<strong>最坏的情况</strong>，就是这个数据序列<strong>本来就有序</strong>，共有 <strong>N</strong> 行，每行分别为 N、N-1、N-2、……、2、1 个，共 <strong>N*(N-1)&#x2F;2</strong> 个。<br>若进行快排，则会有<strong>时间复杂度O(N^2)<strong>，效率非常低，但是我们可以发现，其实本来就不需要排多少个，居然会花了这么久的时间，所以就有了三数取中的方法，</strong>避免了这种最坏的情况。</strong></p>
<img src="../images/blog_images/image-20220716164759111.png" alt="image-20220716164759111" style="zoom:67%;" />
</blockquote>
<blockquote>
<p><strong>三数取中：</strong></p>
<p>将每次所给的区间中的 <strong>最左边的值 、最右边的值、 最中间的值</strong> ，<strong>挑大小为中间的那个</strong>，<strong>并将这个数与最左边的数交换位置</strong>。（因为后面三个版本的排序都以最左边的值为key）。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetMidIndex</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>); <span class="comment">// 运用位运算符防止溢出</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (a[left] &lt; a[mid])</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (a[mid] &lt; a[right])</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (a[right] &lt; a[left])</span><br><span class="line">             <span class="keyword">return</span> left;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> right;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>  <span class="comment">//a[left] &gt;= a[mid]</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (a[right] &lt; a[mid])</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (a[left] &lt; a[right])</span><br><span class="line">             <span class="keyword">return</span> left;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>小区间优化:</strong></p>
<p>当要排的数据序列较大的时候，递归的层数就越深，特别是最后那几层或者几十层。但是我们仔细一想，其实在快排的前面的递归中，大部分区间的数据已经是解决有序了，所以这个时候我们<strong>可以考虑让剩下的几层或者几十层使用插入排序</strong>，进行优化，<strong>减少递归的深度，防止过多的开辟栈空间。</strong>（效率其实是相差不大的，如今编译器对递归的优化很大，不亚于迭代）</p>
</blockquote>
<p>所以将上述的两种优化放到快排的主函数中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 记得递归返回条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分小区间，数据多的继续递归，少的就直接插入排序</span></span><br><span class="line">    <span class="comment">// 这里的小区间取不同的大小，效果不一样，得看要排的数据多大</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &gt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//三数取中</span></span><br><span class="line">        <span class="type">int</span> mid = GetMidIndex(a, left, right);</span><br><span class="line">        Swap(&amp;a[mid], &amp;a[left]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> key = PartSort1(a, left, right);</span><br><span class="line">        QuickSort(a, left, key - <span class="number">1</span>);</span><br><span class="line">        QuickSort(a, key + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertSort(a + left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1、hoare版本"><a href="#1、hoare版本" class="headerlink" title="1、hoare版本"></a>1、hoare版本</h5><blockquote>
<p><strong>hoare版本</strong>比较经典，就是 <strong>左右指针法</strong> 的思路。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>选出一个 <strong>key</strong>， 一般选最左边的值为 <strong>key</strong>，因为我们通过了三数取中的优化，不怕出现最坏的情况。</li>
<li>然后先让 <strong>right</strong> 从右边开始向左走，直到找到<strong>比 key处的值 要小的数 或者 遇到了 left</strong>。</li>
<li>若 <strong>right</strong> 找到后，就让 <strong>left</strong> 向右走，直到找到<strong>比 key处的值 要大的数 或者 遇到了 right</strong>。</li>
<li>交换 <strong>left</strong> 与 <strong>right</strong> 的值，然后一直循环，直到两个指针相遇。</li>
<li>最后将 <strong>key处的值</strong> 与 <strong>left处的值交换</strong>，将 <strong>left</strong> 作为返回值返回。</li>
</ol>
</blockquote>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hoareQuickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key = left;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 记得判断left &lt; right，以及要a[right]要&gt;=a[key]，否则死循环</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= arr[key])</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= arr[key])</span><br><span class="line">            left++;</span><br><span class="line">        </span><br><span class="line">        Swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是右边先动，所以相遇时候left一定小于key的值，所以无需判断</span></span><br><span class="line">    Swap(&amp;arr[key], &amp;arr[left]);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、挖坑法"><a href="#2、挖坑法" class="headerlink" title="2、挖坑法"></a>2、挖坑法</h5><blockquote>
<p>挖坑法顾名思义就是不断挖坑:smile:</p>
<img src="../images/blog_images/image-20220716171725562.png" alt="image-20220716171725562" style="zoom: 80%;" />

<p><strong>步骤：</strong></p>
<ol>
<li>选取最左值为 <strong>hole 值</strong>，并将<strong>最左侧的位置想象成一个坑</strong>（默认已经三数取中优化）</li>
<li><strong>right</strong> 从右边往左开始找<strong>比 hole 小的值</strong>，若找到了，则将 <strong>right处的值</strong> 赋给 <strong>left处</strong>，然后把 <strong>right处想象成新坑</strong>！</li>
<li><strong>left</strong> 从左往右开始找<strong>比 hoke 大的值</strong>，若找到了，则将 <strong>left处的值</strong> 赋给 <strong>right处</strong>，然后把 <strong>left处想象成新坑</strong>！</li>
<li>直到 <strong>left 与 right</strong> 相遇，然后将 <strong>hole</strong> 填到最后的 <strong>left处</strong>，补上坑。</li>
<li>最后返回 <strong>left</strong> 即可。</li>
</ol>
</blockquote>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">holeQuickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hole = arr[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找大的</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= hole)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="comment">// 填左边的坑，右边形成了新坑</span></span><br><span class="line">        a[left] = a[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找小的</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= hole)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="comment">// 填右边的坑，左边形成了新坑</span></span><br><span class="line">        a[right] = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后用hole把坑填住</span></span><br><span class="line">    a[left] = hole;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3、前后指针法"><a href="#3、前后指针法" class="headerlink" title="3、前后指针法"></a>3、前后指针法</h5><blockquote>
<img src="../images/blog_images/image-20220716172543590.png" alt="image-20220716172543590" style="zoom: 67%;" />

<p><strong>步骤:</strong></p>
<ol>
<li>取最左边为 <strong>key</strong>，然后让 <strong>prev</strong> 与 <strong>cur</strong> 一前一后指向数据序列。（默认已经三数取中优化）</li>
<li>让 <strong>cur</strong> 先走，找<strong>比 key处小的值</strong>，直到出界。</li>
<li>若 <strong>cur</strong> 找到了小的，则先让 <strong>prev++</strong> ，然后判断 <strong>cur处是否与 prev处</strong> 是相同的，若相同则无需交换，若不同再交换 <strong>cur 与 prev 处的数据</strong>。</li>
<li>若 <strong>cur</strong> 走到出界了，则交换 <strong>prev 与 key 处的值</strong>。</li>
</ol>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> back-and-forthQuickSort(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key = left;</span><br><span class="line">    <span class="type">int</span> prev = left;</span><br><span class="line">    <span class="type">int</span> cur = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[cur] &lt; a[key] &amp;&amp; prev != cur)</span><br><span class="line">        &#123;</span><br><span class="line">            prev++;</span><br><span class="line">            Swap(&amp;arr[prev], &amp;arr[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    Swap(&amp;arr[key], &amp;arr[prev]);</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="非递归实现版本（栈或队列实现，这里用栈）"><a href="#非递归实现版本（栈或队列实现，这里用栈）" class="headerlink" title="非递归实现版本（栈或队列实现，这里用栈）"></a>非递归实现版本（栈或队列实现，这里用栈）</h4><blockquote>
<p><strong>思路：</strong></p>
<p><strong>用栈来存储每个子区间的下标。</strong><br>首先将 <strong>left 和 right</strong> 入栈，然后进入循环，用 <strong>begin 和 end <strong>分别标记每次 <strong>出栈的左右区间</strong>。接着</strong>对该区间进行排序</strong>（可以用我们前面实现的三种方式的其中一种），并标注 <strong>key</strong> ，然后<strong>继续将新的</strong> <strong>[ begin, key - 1 ] , [ key + 1, end ]</strong> <strong>入栈</strong>。<br>若区间只有一个元素了则不入栈。</p>
<p><strong>注：</strong></p>
<p>用迭代主要是为了解决 <strong>递归栈溢出</strong> 的问题，而不是速度问题，因为现在的编译器优化已经做的很好了。</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickNonSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//三数取中</span></span><br><span class="line">    <span class="type">int</span> mid = GetMidIndex(a, left, right);</span><br><span class="line">    Swap(&amp;a[mid], &amp;a[left]);</span><br><span class="line">    </span><br><span class="line">    Stack st; <span class="comment">//初始化队列，顺便将left和right放进去</span></span><br><span class="line">    StackInit(&amp;st);</span><br><span class="line">    StackPush(&amp;st, left);</span><br><span class="line">    StackPush(&amp;st, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(&amp;st))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先拿到的是右区间</span></span><br><span class="line">        <span class="type">int</span> end = StackTop(&amp;st);</span><br><span class="line">        StackPop(&amp;st);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再拿到的才是左区间</span></span><br><span class="line">        <span class="type">int</span> begin = StackTop(&amp;st);</span><br><span class="line">        StackPop(&amp;st);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> key = holeQuickSort(arr, begin, end);</span><br><span class="line">        <span class="keyword">if</span>(begin &lt; key - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StackPush(&amp;st, begin);</span><br><span class="line">            StackPush(&amp;st, key - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key + <span class="number">1</span> &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            StackPush(&amp;st, key + <span class="number">1</span>);</span><br><span class="line">            StackPush(&amp;st, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StackDestroy(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7、归并排序🛺"><a href="#7、归并排序🛺" class="headerlink" title="7、归并排序🛺"></a>7、归并排序🛺</h3><blockquote>
<p><strong>基本思想：</strong></p>
<p><strong>归并排序（MERGE-SORT）</strong>是建立在归并操作上的一种有效的排序算法,该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。<strong>将已有序的子序列合并，得到完全有序的序列</strong>；即先使每个子序列有序，再使子序列段间有序。<strong>若将两个有序表合并成一个有序表，称为二路归并</strong>。 归并排序核心步骤：</p>
<img src="../images/blog_images/guibing.png" alt="guibing.png" style="zoom: 67%;" />

<img src="../images/blog_images/guibing2.png" alt="guibing2.png" style="zoom: 67%;" />

<p><strong>归并排序的特性总结：</strong></p>
<ol>
<li><p><strong>归并的缺点在于需要O(N)的空间复杂度</strong>，归并排序的思考更多的是<strong>解决在磁盘中的外排序问题</strong>。</p>
</li>
<li><p>时间复杂度：<strong>O(N*logN)</strong>  （类似于二叉树，分解时共有 logN 行，每行合并的有 N 个，所以为 N*logN）</p>
</li>
<li><p>空间复杂度：<strong>O(N)</strong>   （要开辟临时数组）</p>
</li>
<li><p>稳定性：<strong>稳定</strong></p>
</li>
</ol>
</blockquote>
<h4 id="归并排序递归实现"><a href="#归并排序递归实现" class="headerlink" title="归并排序递归实现"></a>归并排序递归实现</h4><blockquote>
<p><strong>思路：</strong></p>
<p>分解与合并过程<strong>类似二叉树的后序遍历</strong>，假设左区间有序了，右区间也有序了，那么一归并，整个数组就有序了。</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> begin1, <span class="type">int</span> end1, <span class="type">int</span> begin2, <span class="type">int</span> end2, <span class="type">int</span>* tmp)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//两端有序子区间归并tmp，并拷贝回去</span></span><br><span class="line">    <span class="type">int</span> j = begin1;</span><br><span class="line">    <span class="type">int</span> i = begin1;</span><br><span class="line">    <span class="keyword">while</span> ((begin1 &lt;= end1) &amp;&amp; (begin2 &lt;= end2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt;= a[begin2])</span><br><span class="line">            tmp[i++] = a[begin1++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[i++] = a[begin2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将有可能还没结束的数据放到tmp中去</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">        tmp[i++] = a[begin1++];</span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">        tmp[i++] = a[begin2++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝回去</span></span><br><span class="line">    <span class="keyword">for</span> (j; j &lt;= end2; j++)</span><br><span class="line">        a[j] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>* tmp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分治步骤:分为[left, mid]和[mid + 1, right] </span></span><br><span class="line">    <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    _MergeSort(a, left, mid, tmp);</span><br><span class="line">    _MergeSort(a, mid + <span class="number">1</span>, right, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于下面迭代（非递归）版本也要用到这部分，所以整合出来当作子函数</span></span><br><span class="line">    Merge(a, left, mid, mid + <span class="number">1</span>, right, tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>  <span class="comment">//归并排序的主函数接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _MergeSort(a, <span class="number">0</span>, n - <span class="number">1</span>, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序非递归实现"><a href="#归并排序非递归实现" class="headerlink" title="归并排序非递归实现"></a>归并排序非递归实现</h4><blockquote>
<p><strong>思路：</strong><br>与递归不同的是，<strong>迭代是不需要分解的。只需要控制好每次归并的区间，让它们从一一归并、二二归并、四四归并……..</strong> 直到最后归并成一个完整的数组。</p>
<p><strong>注意要点：</strong><br>归并时候可能存在的三种情况：（1、2点可合成为一点处理）</p>
<ol>
<li><strong>最后一个小组归并时，第一个小区间不够 gap 个，那么就不需要归并</strong></li>
<li><strong>最后一个小组归并时，第二个小区间不存在， 那么就不需要归并</strong></li>
<li><strong>最后一个小组归并时，第二个小区间存在，第二个区间不够 gap 个，那么只需要归并到第二个小区间的末尾即可</strong></li>
</ol>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += gap * <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对区间[i, i+gap-1] [i+gap, i+2*gap-1]归并</span></span><br><span class="line">            <span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//归并最后一小组时，如果不存在第二个小区间，则无需归并</span></span><br><span class="line">            <span class="keyword">if</span> (begin2 &gt;= n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//归并最后一小组时，如果第二个小区间不够gap个，则要调整一下end2</span></span><br><span class="line">            <span class="keyword">if</span> (end2 &gt;= n)</span><br><span class="line">                end2 = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            Merge(a, begin1, end1, begin2, end2, tmp); <span class="comment">//这个子函数在递归版本中</span></span><br><span class="line">        &#125;</span><br><span class="line">        gap *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8、非比较排序（计数排序）"><a href="#8、非比较排序（计数排序）" class="headerlink" title="8、非比较排序（计数排序）"></a>8、非比较排序（计数排序）</h3><blockquote>
<p><strong>思想：计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用</strong>。 操作步骤：</p>
<ol>
<li><p>统计相同元素出现次数</p>
</li>
<li><p>根据统计的结果将序列回收到原来的序列中</p>
</li>
</ol>
<p><strong>计数排序的特性总结：</strong></p>
<ol>
<li><p>计数排序在数据范围<strong>集中时，效率很高</strong>，但是<strong>适用范围及场景有限</strong>，并且只适合整数，如果是浮点数、字符串等等就不行了。</p>
</li>
<li><p>时间复杂度：<strong>O(MAX(N,范围))</strong></p>
</li>
<li><p>空间复杂度：<strong>O(范围)</strong></p>
</li>
<li><p>稳定性：<strong>稳定</strong></p>
</li>
</ol>
</blockquote>
<p><strong>思考：</strong>若最小的数是从一万开始的，那前面的空间都浪费了，咋办？</p>
<p><strong>方法：</strong> 先求出原数组的 <strong>max 和 min</strong>，然后开辟的数组只需要开辟 <strong>max - min + 1</strong> 个空间就行。<br>            但在计数时候要记得 <strong>减去 min</strong>，在回收的时候记得 <strong>加上 min</strong>。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CountSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先找数组里面的最大值和最小值</span></span><br><span class="line">    <span class="type">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> min = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">            min = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出开辟空间的范围和大小</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* count = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * range);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * range);<span class="comment">//记得初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希映射，注意这里要减去范围的最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        count[a[i] - min] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收排序好的数据，记得加上范围的最小值</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i]--)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j++] = i + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9、基数排序"><a href="#9、基数排序" class="headerlink" title="9、基数排序"></a>9、基数排序</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>排序算法是一种<strong>非比较</strong>算法，其原理是将整数<strong>按每个位数分别比较</strong>。它利用了桶的思想。</p>
<p>代码：（这里实现借助的是队列queue，比较方便）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COUNT = <span class="number">3</span>; <span class="comment">// 最大的位数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_RADIX = <span class="number">10</span>; <span class="comment">// 最大的基数桶数</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q[MAX_RADIX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetKey</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> <span class="comment">// 获得关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (k--)</span><br><span class="line">	&#123;</span><br><span class="line">		key = n % <span class="number">10</span>;</span><br><span class="line">		n /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Distribute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> key = <span class="built_in">GetKey</span>(v[i], k);</span><br><span class="line">		q[key].<span class="built_in">push</span>(v[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Collect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; MAX_RADIX; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (!q[k].<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			v[i++] = q[k].<span class="built_in">front</span>();</span><br><span class="line">			q[k].<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= MAX_COUNT; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 分发数据</span></span><br><span class="line">		<span class="built_in">Distribute</span>(v, left, right, k);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 回收数据</span></span><br><span class="line">		<span class="built_in">Collect</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">278</span>, <span class="number">109</span>, <span class="number">63</span>, <span class="number">930</span>, <span class="number">589</span>, <span class="number">184</span>, <span class="number">505</span>, <span class="number">269</span>, <span class="number">8</span>, <span class="number">83</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">radixsort</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	it = v.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Ⅲ、排序算法复杂度以及稳定性的分析"><a href="#Ⅲ、排序算法复杂度以及稳定性的分析" class="headerlink" title="Ⅲ、排序算法复杂度以及稳定性的分析"></a>Ⅲ、排序算法复杂度以及稳定性的分析</h2><blockquote>
<p><img src="/../images/blog_images/image-20220716211912948.png" alt="image-20220716211912948"></p>
<p><img src="/../images/blog_images/paixvbiaoge.png" alt="QQ图片20220716212250"></p>
<p><strong>基数排序也是稳定的！</strong></p>
</blockquote>
<p><strong>稳定性应用：</strong>考试交卷之后，自动评卷拿到成绩，成绩按交卷顺序填到数组中，然后我们对数组进行排序，进行排名。要求：若分数相同，先交卷的排在前面。所以用了不稳定的排序， 可能会改变相对顺序。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
